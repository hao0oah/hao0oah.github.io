---
title: synchronized优化原理
date: 2024-07-08 19:19:29
tags:
    - Java
    - synchronized
    - 多线程
    - 并发编程
categories: Java
---

### 前言

前面介绍了从JVM源码看`synchronized`底层原理，讲的太乱太杂有点看不懂，先留着以后慢慢看。

这篇主要讲解面试中常问到的知识点：锁的几种状态，锁的膨胀以及锁的优化等。

<!-- more -->

### synchronized锁的4种状态

根据`Mark Word`中锁标志位和是否偏向，锁的状态总共分四种：**无锁状态**(001)、**偏向锁**(101)、**轻量级锁**(00)和重量级锁(10)。锁随着竞争情况可以升级，但锁升级后不能降级，意味着不能从轻量级锁状态降级为偏向锁状态，也不能从重量级锁状态降级为轻量级锁状态。

#### 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

当一个线程访问同步代码块并获取锁时，会在`Mark Word`里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测`Mark Word`里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。

![](https://s2.loli.net/2024/07/15/cOuzJMXwSaGrv2U.jpg)

#### 轻量级锁

当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（`Lock Record`）的空间，用于存储锁对象目前的`Mark Word`的拷贝，然后拷贝对象头中的`Mark Word`复制到锁记录中。

![](https://s2.loli.net/2024/07/15/5McFnEVs6ZpPzeI.jpg)

拷贝成功后，虚拟机将使用CAS操作尝试将对象的`Mark Word`更新为指向`Lock Record`的指针，并将`Lock Record`里的`owner`指针指向对象的`Mark Word`。

![](https://s2.loli.net/2024/07/15/6j1u2TI4d9ESF5D.jpg)

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象`Mark Word`的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

![](C:\Users\haoxi\Pictures\博客保存\1003\lock3.jpeg)

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的`Mark Word`是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那么再添加一条 `Lock Record` 作为重入的计数，然后就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

![](https://s2.loli.net/2024/07/15/cDaQv1dhw37znxE.jpg)

**解锁1：** 当线程退出 `synchronized`代码块的时候，如果获取的是取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

**解锁2：** 当线程退出 `synchronized` 代码块的时候，如果获取的锁记录取值不为 null，那么使用 CAS 将 `Mark Word` 的值恢复给对象头

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

### 锁膨胀

在加锁的时候发现其他线程对该对象加上了轻量级锁，这时CAS 操作失败，需要进行锁膨胀，将轻量级变为重量级锁。

1、当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁，此时加锁失败。

![](https://s2.loli.net/2024/07/15/O8mC4wVJ2qPy3ar.jpg)

2、这时 Thread-1 加轻量级锁失败，进入锁膨胀流程，

- 既为 Object 对象申请 `Monitor` 锁，让 Object 指向重量级锁地址。
- 然后Thread-1自己进入 `Monitor` 的 `EntryList Blocked` 中阻塞。

![](https://s2.loli.net/2024/07/15/kdhPpXnK4ZUwFTL.jpg)

3、当 Thread-0 退出同步块解锁时，使用 CAS 将 `Mark Word` 的值恢复给 对象头，因为 Object 指向的是 `Monitor` ，就会失败，所以会进入重量级解锁流程，即按照 `Monitor` 地址找到 `Monitor` 对象，设置 `Owner` 为null，唤醒 `EntryList` 中 `BLOCKED` 线程，Thread-1 此时就参与重量级锁的竞争。

### 自旋优化

重量级锁竞争时，还可以使用自旋来进行优化，**就是让阻塞的线程循环查看几次**，等待一段次数后再进入阻塞，如果当前线程自旋成功（即这时候锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

- 在Java 6 之后 自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就会自旋几次；反之，就会少自旋甚至不自旋。
- java 7 之后不能控制是否开启自旋功能。

#### 重量级锁

升级为重量级锁时，锁标志的状态值变为“10”，此时`Mark Word`中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

整体的锁状态升级流程如下：

![](https://s2.loli.net/2024/07/15/PsjcRz7X4Ae8diq.png)

综上，偏向锁通过对比`Mark Word`解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

### 参考

https://juejin.cn/post/7001483226678034439

https://juejin.cn/post/6844903590050398216

https://tech.meituan.com/2018/11/15/java-lock.html

https://wujiazhen2.github.io/2018/08/20/synchronized%E5%8E%9F%E7%90%86/